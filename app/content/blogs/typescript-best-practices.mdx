---
title: "TypeScript Best Practices"
slug: "typescript-best-practices"
description: "Advanced TypeScript patterns and best practices for building maintainable applications."
tags: ["typescript", "javascript", "frontend", "best-practices"]
category: "Frontend"
date: "2024-12-03"
coverImage: "https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=800&h=600&fit=crop&crop=center"
ogImage: "https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=1200&h=630&fit=crop&crop=center"
author:
  name: "Devure Team"
  profileUrl: "/authors/devure-team"
---

## Introduction

TypeScript has become the standard for building large-scale JavaScript applications. This guide covers advanced patterns and best practices to write maintainable, type-safe code.

### Type Definitions

Start with well-defined types:

```typescript
// Use interfaces for object shapes
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

// Use types for unions and complex types
type UserRole = "admin" | "user" | "moderator";
type ApiResponse<T> = {
  data: T;
  status: number;
  message: string;
};
```

### Generic Types

Leverage generics for reusable components:

```typescript
// Generic function
function identity<T>(arg: T): T {
  return arg;
}

// Generic interface
interface Repository<T> {
  findById(id: string): Promise<T | null>;
  save(entity: T): Promise<T>;
  delete(id: string): Promise<void>;
}

// Generic class
class DataStore<T> {
  private data: T[] = [];

  add(item: T): void {
    this.data.push(item);
  }

  get(index: number): T | undefined {
    return this.data[index];
  }
}
```

### Utility Types

TypeScript provides powerful utility types:

```typescript
// Partial - makes all properties optional
type PartialUser = Partial<User>;

// Pick - selects specific properties
type UserBasicInfo = Pick<User, "id" | "name">;

// Omit - excludes specific properties
type UserWithoutId = Omit<User, "id">;

// Record - creates object type with specific keys
type UserRoles = Record<string, UserRole>;

// ReturnType - extracts return type of function
type ApiResponseType = ReturnType<typeof fetchUser>;
```

### Advanced Patterns

#### Discriminated Unions

```typescript
type LoadingState = {
  status: "loading";
};

type SuccessState = {
  status: "success";
  data: User;
};

type ErrorState = {
  status: "error";
  error: string;
};

type AsyncState = LoadingState | SuccessState | ErrorState;

function handleState(state: AsyncState) {
  switch (state.status) {
    case "loading":
      return "Loading...";
    case "success":
      return `User: ${state.data.name}`;
    case "error":
      return `Error: ${state.error}`;
  }
}
```

#### Mapped Types

```typescript
// Make all properties readonly
type ReadonlyUser = {
  readonly [K in keyof User]: User[K];
};

// Make all properties optional and nullable
type OptionalUser = {
  [K in keyof User]?: User[K] | null;
};
```

### Error Handling

Use Result types for better error handling:

```typescript
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

async function fetchUser(id: string): Promise<Result<User>> {
  try {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) {
      return { success: false, error: new Error("User not found") };
    }
    const user = await response.json();
    return { success: true, data: user };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}
```

### React with TypeScript

#### Component Props

```typescript
interface ButtonProps {
  children: React.ReactNode;
  variant?: "primary" | "secondary";
  size?: "small" | "medium" | "large";
  onClick?: () => void;
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({
  children,
  variant = "primary",
  size = "medium",
  onClick,
  disabled = false,
}) => {
  return (
    <button
      className={`btn btn-${variant} btn-${size}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
};
```

#### Custom Hooks

```typescript
function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue] as const;
}
```

### Conclusion

TypeScript's type system is incredibly powerful. Use these patterns to write more maintainable and robust code. Remember that TypeScript is a tool to help you catch errors early and provide better developer experience.
